## Task 31: Refine Audio Output Handling and API Endpoint for TTS/VC

**Focus:**
This task focuses on standardizing how audio generated by `ChatterboxTTSTool` (both TTS and VC) is handled and made accessible. Instead of just returning a base64 snippet or relying on an implicit understanding of `download_work_dir_file`, we will:
1.  Ensure audio is consistently saved to a well-defined location within `work_dir` (e.g., `work_dir/outputs/audio/`).
2.  Return a structured response from the tool that includes a URL or a clear relative path that can be used by an Agent Zero API endpoint to serve the audio file.
3.  Create or adapt an existing Agent Zero API endpoint (e.g., `/api/get_audio_file`) specifically for serving these generated audio files. This endpoint will take the relative path and serve the file with the correct MIME type.

**File Paths and Code Changes:**

1.  **Define Audio Output Directory in `python/helpers/files.py` or `runtime.py`:**
    It's good practice to have a central way to get paths for generated files.

    ```python
# python/helpers/files.py (or runtime.py)
    # ... (existing file helper functions)
    from pathlib import Path

    def get_tts_output_dir_abs(agent_context_id: Optional[str] = None) -> Path:
        """Returns the absolute path to the TTS/VC output directory."""
        # Base work_dir path (e.g., /a0/work_dir in Docker, ./work_dir locally)
        # Assuming get_abs_path("work_dir") gives the root of the work_dir.
        # Or, if context has a specific work_dir: self.agent.context.get_work_dir_path()
        
        # For now, let's assume a global work_dir structure.
        # Agent Zero's existing code uses get_abs_path("tmp/upload")
        # We can use a similar pattern for generated audio.
        base_work_dir = get_abs_path(os.getenv("AGENT_WORK_DIR", "work_dir")) # AGENT_WORK_DIR could be 'root' in Docker
        
        # If we want outputs to be per-context, we could use agent_context_id
        # output_path = base_work_dir / "outputs" / "audio"
        # For simplicity with existing download_work_dir_file, let's put it under tmp
        # which is often part of the work_dir.
        output_path = base_work_dir / "tmp" / "audio_outputs"
        
        output_path.mkdir(parents=True, exist_ok=True)
        return output_path

    def get_tts_output_web_path(filename: str, agent_context_id: Optional[str] = None) -> str:
        """Returns a web-accessible relative path for a TTS file."""
        # This path should be relative to what the download API endpoint expects.
        # If download_work_dir_file serves from the root of "work_dir",
        # and files are in "work_dir/tmp/audio_outputs/", then path is "tmp/audio_outputs/filename"
        return f"tmp/audio_outputs/{filename}"
```
    **Note:** Agent Zero's `download_work_dir_file.py` currently serves from `/root` or `./work_dir`. The path generated by `get_tts_output_web_path` must be relative to this base. If `work_dir` is `/root`, then paths like `/tmp/audio_outputs/file.wav` would be accessed via the API as `tmp/audio_outputs/file.wav`.

2.  **Modify `python/tools/chatterbox_tts_tool.py`:**
    *   Use the new helper functions to save audio files to the standardized location.
    *   Return the web-accessible relative path in the tool's response data.

    ```python
# python/tools/chatterbox_tts_tool.py
    # ... (imports as in Task 30)
    from python.helpers.files import get_tts_output_dir_abs, get_tts_output_web_path # New import

    class ChatterboxTTSTool(Tool):
        # ... (__init__, _get_tts_handler, _get_vc_handler, _emit_tts_event, execute as in Task 30)

        async def _save_audio_and_get_path(self, audio_bytes: bytes, sr: int, prefix: str) -> Optional[str]:
            """Saves audio bytes to a file and returns its web-accessible relative path."""
            output_dir = get_tts_output_dir_abs() # No context ID passed, so it's a global shared tmp dir
            
            filename = f"{prefix}_{uuid.uuid4()}.wav"
            filepath_abs = output_dir / filename
            
            try:
                import torchaudio
                audio_tensor = torch.from_numpy(np.frombuffer(audio_bytes, dtype=np.float32))
                if audio_tensor.ndim == 1: audio_tensor = audio_tensor.unsqueeze(0)
                
                # Run torchaudio.save in a separate thread as it can be blocking
                await asyncio.to_thread(torchaudio.save, str(filepath_abs), audio_tensor, sr)
                
                web_path = get_tts_output_web_path(filename) # Get the relative path for API access
                print(f"ChatterboxTTSTool: Saved audio to {filepath_abs}, web path: {web_path}")
                return web_path
            except Exception as e:
                print(f"ChatterboxTTSTool: Error saving audio to file {filepath_abs}: {e}")
                return None

        async def _generate_speech(self, tts_handler: ChatterboxTTSHandler, text: str, audio_prompt_path: Optional[str], 
                                   exaggeration: float, cfg_weight: float, temperature: float) -> ToolResponse:
            await self._emit_tts_event("generate_speech", "starting", {"text_length": len(text), "prompt": bool(audio_prompt_path)})
            
            try:
                sr, audio_bytes = await tts_handler.generate_speech(
                    text, audio_prompt_path, exaggeration, cfg_weight, temperature
                )
            except Exception as e:
                await self._emit_tts_event("generate_speech", "error", {"error": str(e)})
                return ToolResponse(message=f"Speech generation failed: {str(e)}", error=True)

            audio_web_path = await self._save_audio_and_get_path(audio_bytes, sr, "tts")
            
            result_details = {
                "sample_rate": sr, 
                "audio_path": audio_web_path if audio_web_path else "Error: Could not save audio file.",
                "audio_duration_seconds": len(audio_bytes) / (sr * np.dtype(np.float32).itemsize)
            }
            status = "completed" if audio_web_path else "failed_to_save"
            await self._emit_tts_event("generate_speech", status, result_details)
            
            if audio_web_path:
                return ToolResponse(message=f"Speech generated successfully. Accessible at: {audio_web_path}", data=result_details)
            else:
                return ToolResponse(message="Speech generated but failed to save.", data=result_details, error=True)


        async def _convert_voice(self, vc_handler: ChatterboxVCHandler, source_audio_path: str, target_voice_path: str) -> ToolResponse:
            await self._emit_tts_event("convert_voice", "starting", {"source": source_audio_path, "target_prompt": target_voice_path})
            
            try:
                sr, audio_bytes = await vc_handler.convert_voice(source_audio_path, target_voice_path)
            except Exception as e:
                await self._emit_tts_event("convert_voice", "error", {"error": str(e)})
                return ToolResponse(message=f"Voice conversion failed: {str(e)}", error=True)

            audio_web_path = await self._save_audio_and_get_path(audio_bytes, sr, "vc")

            result_details = {
                "sample_rate": sr, 
                "audio_path": audio_web_path if audio_web_path else "Error: Could not save audio file.",
                "audio_duration_seconds": len(audio_bytes) / (sr * np.dtype(np.float32).itemsize)
            }
            status = "completed" if audio_web_path else "failed_to_save"
            await self._emit_tts_event("convert_voice", status, result_details)

            if audio_web_path:
                return ToolResponse(message=f"Voice conversion successful. Accessible at: {audio_web_path}", data=result_details)
            else:
                return ToolResponse(message="Voice conversion successful but failed to save.", data=result_details, error=True)
```

3.  **Create/Modify an API endpoint for serving audio files:**
    Agent Zero has `python/api/download_work_dir_file.py`. We can adapt this or create a new one. Let's assume we adapt `download_work_dir_file.py` to also handle `.wav` files correctly with the right MIME type.

    **Modify `python/api/download_work_dir_file.py`:**
    *   Ensure it can serve `.wav` files with `audio/wav` MIME type.
    *   It already takes a `path` argument relative to the `work_dir_base`.

    ```python
# python/api/download_work_dir_file.py
    from flask import request, send_from_directory, Response # Response for custom errors
    from python.helpers.api import ApiHandler, Input, Output # Keep these for consistency
    from python.helpers import files, runtime
    import os
    import mimetypes # For guessing MIME types

    class DownloadWorkDirFile(ApiHandler):
        async def process(self, input: Input, flask_request: request) -> Output: # flask_request name change for clarity
            file_path_relative = input.get("path", "") # Path relative to work_dir
            if not file_path_relative:
                return {"error": "No path provided"}, 400

            # Construct absolute path and ensure it's within the work directory
            work_dir_base = files.get_work_dir_base_path() # This needs to be defined in files.py
            
            # Sanitize path to prevent directory traversal
            # os.path.normpath will resolve '..' and '.'
            # We must still ensure the final path is within work_dir_base
            unsafe_full_path = os.path.join(work_dir_base, file_path_relative)
            safe_full_path = os.path.normpath(unsafe_full_path)

            if not safe_full_path.startswith(os.path.normpath(work_dir_base) + os.sep) and \
               safe_full_path != os.path.normpath(work_dir_base): # check for exact match for base itself
                print(f"DownloadWorkDirFile: Access denied for path '{file_path_relative}'. Resolved to '{safe_full_path}', which is outside base '{work_dir_base}'")
                return {"error": "Access denied to the specified path."}, 403

            if not os.path.exists(safe_full_path) or not os.path.isfile(safe_full_path):
                print(f"DownloadWorkDirFile: File not found at '{safe_full_path}' (relative: '{file_path_relative}')")
                return {"error": "File not found."}, 404

            directory = os.path.dirname(safe_full_path)
            filename = os.path.basename(safe_full_path)
            
            # Guess MIME type
            mimetype = mimetypes.guess_type(filename)[0]
            if not mimetype:
                mimetype = 'application/octet-stream' # Default if unknown
            
            # Specifically handle wav if mimetypes doesn't get it right or for overrides
            if filename.lower().endswith(".wav"):
                mimetype = "audio/wav"

            print(f"DownloadWorkDirFile: Serving '{filename}' from '{directory}' with MIME type '{mimetype}'")
            
            # send_from_directory is a Flask helper that handles security and serving.
            # It needs directory and filename separately.
            # The `directory` argument must be an absolute path.
            return send_from_directory(directory, filename, mimetype=mimetype, as_attachment=False)
            # `as_attachment=False` tries to display in browser if possible. True forces download.
```
    **Add `get_work_dir_base_path` to `python/helpers/files.py`:**
    ```python
# python/helpers/files.py
    # ...
    def get_work_dir_base_path() -> str:
        """Returns the absolute path to the base work directory."""
        # This should align with how work_dir is defined throughout Agent Zero
        # (e.g., /root in Docker, ./work_dir locally)
        return get_abs_path(os.getenv("AGENT_WORK_DIR", "work_dir"))
```

**Dependencies/Prerequisites:**
*   Tasks 1-29 completed.
*   `chatterbox-tts` library and its dependencies installed.
*   `torchaudio` (usually a dependency of `chatterbox-tts` or `torch`) for saving WAV files.
*   Standard Python libraries (`os`, `pathlib`, `uuid`, `base64`, `mimetypes`).

**Integration with Agent Zero:**
*   `ChatterboxTTSTool` now saves generated audio to a standardized subdirectory (`work_dir/tmp/audio_outputs/`).
*   The tool's response includes an `audio_path` (relative path) that can be used with the updated `/api/download_work_dir_file` endpoint.
*   The `/api/download_work_dir_file` endpoint is enhanced to correctly serve `.wav` files with the `audio/wav` MIME type and includes better path sanitization.

**Chatterbox TTS Integration Requirements for this Task:**
*   This task directly refines the output handling of the Chatterbox integration, making the generated audio files accessible via an API.

**Docker Compatibility:**
*   Ensure the `work_dir/tmp/audio_outputs/` directory (or `/root/tmp/audio_outputs/` inside Docker if `AGENT_WORK_DIR` is `root`) is writable by the application. If `work_dir` is a volume, this should be fine.
*   No new Python package dependencies are added beyond what's needed for `chatterbox-tts`.

**Summary of Task 31:**
This task standardizes audio file output for the `ChatterboxTTSTool`. Generated TTS and VC audio files are now saved to a consistent location within Agent Zero's working directory structure. The tool returns a relative path that can be used with an improved API endpoint (`/api/download_work_dir_file`) to serve these audio files with the correct MIME type. This makes the audio output cleanly accessible to frontends or other services.

Please confirm to proceed.Okay, let's proceed with Task 31.

## Task 31: Refine Audio Output Handling and API Endpoint for TTS/VC

**Focus:**
This task focuses on standardizing how audio generated by `ChatterboxTTSTool` (both TTS and VC) is handled and made accessible. Instead of just returning a base64 snippet or relying on an implicit understanding of `download_work_dir_file`, we will:
1.  Ensure audio is consistently saved to a well-defined location within `work_dir` (e.g., `work_dir/outputs/audio/`).
2.  Return a structured response from the tool that includes a URL or a clear relative path that can be used by an Agent Zero API endpoint to serve the audio file.
3.  Create or adapt an existing Agent Zero API endpoint (e.g., `/api/get_audio_file`) specifically for serving these generated audio files. This endpoint will take the relative path and serve the file with the correct MIME type.

**File Paths and Code Changes:**

1.  **Define Audio Output Directory in `python/helpers/files.py` or `runtime.py`:**
    It's good practice to have a central way to get paths for generated files.

    ```python
    # python/helpers/files.py (or runtime.py)
    # ... (existing file helper functions)
    from pathlib import Path

    def get_tts_output_dir_abs(agent_context_id: Optional[str] = None) -> Path:
        """Returns the absolute path to the TTS/VC output directory."""
        # Base work_dir path (e.g., /a0/work_dir in Docker, ./work_dir locally)
        # Assuming get_abs_path("work_dir") gives the root of the work_dir.
        # Or, if context has a specific work_dir: self.agent.context.get_work_dir_path()
        
        # For now, let's assume a global work_dir structure.
        # Agent Zero's existing code uses get_abs_path("tmp/upload")
        # We can use a similar pattern for generated audio.
        base_work_dir = get_abs_path(os.getenv("AGENT_WORK_DIR", "work_dir")) # AGENT_WORK_DIR could be 'root' in Docker
        
        # If we want outputs to be per-context, we could use agent_context_id
        # output_path = base_work_dir / "outputs" / "audio"
        # For simplicity with existing download_work_dir_file, let's put it under tmp
        # which is often part of the work_dir.
        output_path = base_work_dir / "tmp" / "audio_outputs"
        
        output_path.mkdir(parents=True, exist_ok=True)
        return output_path

    def get_tts_output_web_path(filename: str, agent_context_id: Optional[str] = None) -> str:
        """Returns a web-accessible relative path for a TTS file."""
        # This path should be relative to what the download API endpoint expects.
        # If download_work_dir_file serves from the root of "work_dir",
        # and files are in "work_dir/tmp/audio_outputs/", then path is "tmp/audio_outputs/filename"
        return f"tmp/audio_outputs/{filename}"

    ```
    **Note:** Agent Zero's `download_work_dir_file.py` currently serves from `/root` or `./work_dir`. The path generated by `get_tts_output_web_path` must be relative to this base. If `work_dir` is `/root`, then paths like `/tmp/audio_outputs/file.wav` would be accessed via the API as `tmp/audio_outputs/file.wav`.

2.  **Modify `python/tools/chatterbox_tts_tool.py`:**
    *   Use the new helper functions to save audio files to the standardized location.
    *   Return the web-accessible relative path in the tool's response data.

    ```python
    # python/tools/chatterbox_tts_tool.py
    # ... (imports as in Task 30)
    from python.helpers.files import get_tts_output_dir_abs, get_tts_output_web_path # New import

    class ChatterboxTTSTool(Tool):
        # ... (__init__, _get_tts_handler, _get_vc_handler, _emit_tts_event, execute as in Task 30)

        async def _save_audio_and_get_path(self, audio_bytes: bytes, sr: int, prefix: str) -> Optional[str]:
            """Saves audio bytes to a file and returns its web-accessible relative path."""
            output_dir = get_tts_output_dir_abs() # No context ID passed, so it's a global shared tmp dir
            
            filename = f"{prefix}_{uuid.uuid4()}.wav"
            filepath_abs = output_dir / filename
            
            try:
                import torchaudio
                audio_tensor = torch.from_numpy(np.frombuffer(audio_bytes, dtype=np.float32))
                if audio_tensor.ndim == 1: audio_tensor = audio_tensor.unsqueeze(0)
                
                # Run torchaudio.save in a separate thread as it can be blocking
                await asyncio.to_thread(torchaudio.save, str(filepath_abs), audio_tensor, sr)
                
                web_path = get_tts_output_web_path(filename) # Get the relative path for API access
                print(f"ChatterboxTTSTool: Saved audio to {filepath_abs}, web path: {web_path}")
                return web_path
            except Exception as e:
                print(f"ChatterboxTTSTool: Error saving audio to file {filepath_abs}: {e}")
                return None

        async def _generate_speech(self, tts_handler: ChatterboxTTSHandler, text: str, audio_prompt_path: Optional[str], 
                                   exaggeration: float, cfg_weight: float, temperature: float) -> ToolResponse:
            await self._emit_tts_event("generate_speech", "starting", {"text_length": len(text), "prompt": bool(audio_prompt_path)})
            
            try:
                sr, audio_bytes = await tts_handler.generate_speech(
                    text, audio_prompt_path, exaggeration, cfg_weight, temperature
                )
            except Exception as e:
                await self._emit_tts_event("generate_speech", "error", {"error": str(e)})
                return ToolResponse(message=f"Speech generation failed: {str(e)}", error=True)

            audio_web_path = await self._save_audio_and_get_path(audio_bytes, sr, "tts")
            
            result_details = {
                "sample_rate": sr, 
                "audio_path": audio_web_path if audio_web_path else "Error: Could not save audio file.",
                "audio_duration_seconds": len(audio_bytes) / (sr * np.dtype(np.float32).itemsize)
            }
            status = "completed" if audio_web_path else "failed_to_save"
            await self._emit_tts_event("generate_speech", status, result_details)
            
            if audio_web_path:
                return ToolResponse(message=f"Speech generated successfully. Accessible at: {audio_web_path}", data=result_details)
            else:
                return ToolResponse(message="Speech generated but failed to save.", data=result_details, error=True)


        async def _convert_voice(self, vc_handler: ChatterboxVCHandler, source_audio_path: str, target_voice_path: str) -> ToolResponse:
            await self._emit_tts_event("convert_voice", "starting", {"source": source_audio_path, "target_prompt": target_voice_path})
            
            try:
                sr, audio_bytes = await vc_handler.convert_voice(source_audio_path, target_voice_path)
            except Exception as e:
                await self._emit_tts_event("convert_voice", "error", {"error": str(e)})
                return ToolResponse(message=f"Voice conversion failed: {str(e)}", error=True)

            audio_web_path = await self._save_audio_and_get_path(audio_bytes, sr, "vc")

            result_details = {
                "sample_rate": sr, 
                "audio_path": audio_web_path if audio_web_path else "Error: Could not save audio file.",
                "audio_duration_seconds": len(audio_bytes) / (sr * np.dtype(np.float32).itemsize)
            }
            status = "completed" if audio_web_path else "failed_to_save"
            await self._emit_tts_event("convert_voice", status, result_details)

            if audio_web_path:
                return ToolResponse(message=f"Voice conversion successful. Accessible at: {audio_web_path}", data=result_details)
            else:
                return ToolResponse(message="Voice conversion successful but failed to save.", data=result_details, error=True)
    ```

3.  **Create/Modify an API endpoint for serving audio files:**
    Agent Zero has `python/api/download_work_dir_file.py`. We can adapt this or create a new one. Let's assume we adapt `download_work_dir_file.py` to also handle `.wav` files correctly with the right MIME type.

    **Modify `python/api/download_work_dir_file.py`:**
    *   Ensure it can serve `.wav` files with `audio/wav` MIME type.
    *   It already takes a `path` argument relative to the `work_dir_base`.

    ```python
    # python/api/download_work_dir_file.py
    from flask import request, send_from_directory, Response # Response for custom errors
    from python.helpers.api import ApiHandler, Input, Output # Keep these for consistency
    from python.helpers import files, runtime
    import os
    import mimetypes # For guessing MIME types

    class DownloadWorkDirFile(ApiHandler):
        async def process(self, input: Input, flask_request: request) -> Output: # flask_request name change for clarity
            file_path_relative = input.get("path", "") # Path relative to work_dir
            if not file_path_relative:
                return {"error": "No path provided"}, 400

            # Construct absolute path and ensure it's within the work directory
            work_dir_base = files.get_work_dir_base_path() # This needs to be defined in files.py
            
            # Sanitize path to prevent directory traversal
            # os.path.normpath will resolve '..' and '.'
            # We must still ensure the final path is within work_dir_base
            unsafe_full_path = os.path.join(work_dir_base, file_path_relative)
            safe_full_path = os.path.normpath(unsafe_full_path)

            if not safe_full_path.startswith(os.path.normpath(work_dir_base) + os.sep) and \
               safe_full_path != os.path.normpath(work_dir_base): # check for exact match for base itself
                print(f"DownloadWorkDirFile: Access denied for path '{file_path_relative}'. Resolved to '{safe_full_path}', which is outside base '{work_dir_base}'")
                return {"error": "Access denied to the specified path."}, 403

            if not os.path.exists(safe_full_path) or not os.path.isfile(safe_full_path):
                print(f"DownloadWorkDirFile: File not found at '{safe_full_path}' (relative: '{file_path_relative}')")
                return {"error": "File not found."}, 404

            directory = os.path.dirname(safe_full_path)
            filename = os.path.basename(safe_full_path)
            
            # Guess MIME type
            mimetype = mimetypes.guess_type(filename)[0]
            if not mimetype:
                mimetype = 'application/octet-stream' # Default if unknown
            
            # Specifically handle wav if mimetypes doesn't get it right or for overrides
            if filename.lower().endswith(".wav"):
                mimetype = "audio/wav"

            print(f"DownloadWorkDirFile: Serving '{filename}' from '{directory}' with MIME type '{mimetype}'")
            
            # send_from_directory is a Flask helper that handles security and serving.
            # It needs directory and filename separately.
            # The `directory` argument must be an absolute path.
            return send_from_directory(directory, filename, mimetype=mimetype, as_attachment=False)
            # `as_attachment=False` tries to display in browser if possible. True forces download.
    ```
    **Add `get_work_dir_base_path` to `python/helpers/files.py`:**
    ```python
    # python/helpers/files.py
    # ...
    def get_work_dir_base_path() -> str:
        """Returns the absolute path to the base work directory."""
        # This should align with how work_dir is defined throughout Agent Zero
        # (e.g., /root in Docker, ./work_dir locally)
        return get_abs_path(os.getenv("AGENT_WORK_DIR", "work_dir"))
    ```

**Dependencies/Prerequisites:**
*   Tasks 1-29 completed.
*   `chatterbox-tts` library and its dependencies installed.
*   `torchaudio` (usually a dependency of `chatterbox-tts` or `torch`) for saving WAV files.
*   Standard Python libraries (`os`, `pathlib`, `uuid`, `base64`, `mimetypes`).

**Integration with Agent Zero:**
*   `ChatterboxTTSTool` now saves generated audio to a standardized subdirectory (`work_dir/tmp/audio_outputs/`).
*   The tool's response includes an `audio_path` (relative path) that can be used with the updated `/api/download_work_dir_file` endpoint.
*   The `/api/download_work_dir_file` endpoint is enhanced to correctly serve `.wav` files with the `audio/wav` MIME type and includes better path sanitization.

**Chatterbox TTS Integration Requirements for this Task:**
*   This task directly refines the output handling of the Chatterbox integration, making the generated audio files accessible via an API.

**Docker Compatibility:**
*   Ensure the `work_dir/tmp/audio_outputs/` directory (or `/root/tmp/audio_outputs/` inside Docker if `AGENT_WORK_DIR` is `root`) is writable by the application. If `work_dir` is a volume, this should be fine.
*   No new Python package dependencies are added beyond what's needed for `chatterbox-tts`.

**Summary of Task 31:**
This task standardizes audio file output for the `ChatterboxTTSTool`. Generated TTS and VC audio files are now saved to a consistent location within Agent Zero's working directory structure. The tool returns a relative path that can be used with an improved API endpoint (`/api/download_work_dir_file`) to serve these audio files with the correct MIME type. This makes the audio output cleanly accessible to frontends or other services.

Please confirm to proceed.