## Task 41: `BrowserAgentTool` - Implement Real AI-driven `act` Logic (LLM-based Action Execution for Basic Actions)

**Focus:**
This task evolves the `BrowserAgentTool`'s `act` functionality by implementing the LLM call within `ActionExecutor` to translate natural language instructions into specific, simple Playwright actions. We will refine the interaction with the LLM and the execution of the parsed actions. The goal is to reliably perform basic actions like clicking identified elements and typing/filling input fields based on reasonably clear natural language.

**Assumptions:**
*   The LLM (e.g., "gpt-4o-mini") is capable of understanding the `ACTION_TRANSLATION_SYSTEM_PROMPT` and returning a JSON object with `action_type`, `selector`, and `value`/`key` as defined in Task 22.
*   Playwright is set up and `BrowserManager` can provide a valid `Page` object.

**File Paths and Code Changes:**

1.  **Refine `python/agents/browser_agent/actions.py` (`ActionExecutor`):**
    *   Enhance `_translate_instruction_to_action` for more robust LLM interaction and error handling.
    *   Enhance `execute_ai_action` to more reliably execute the LLM's suggested actions using Playwright, including handling cases where a selector might not be immediately found or is ambiguous. This version will still focus on direct execution of the LLM's *single* suggested action rather than a Stagehand-like multi-step reasoning over the page.

    ```python
# python/agents/browser_agent/actions.py
    import asyncio
    from typing import Dict, Any, Optional, List
    from playwright.async_api import Page as PWPage, PlaywrightError, TimeoutError as PlaywrightTimeoutError
    import json
    import os
    import re # For simple text cleaning
    from openai import OpenAI, APIError, RateLimitError, BadRequestError
    from dotenv import load_dotenv
    from pathlib import Path
    import logging

    logger = logging.getLogger(__name__)

    project_root = Path(__file__).resolve().parents[2] # Adjust if structure changes
    dotenv_path = project_root / '.env'
    load_dotenv(dotenv_path, override=True)

    ACTION_TRANSLATION_SYSTEM_PROMPT = """
    You are an expert at translating natural language browser interaction commands into specific Playwright actions and CSS selectors.
    Given current page context (like title and interactive elements) and a user instruction, identify the single, most direct browser action to perform.
    Respond with a JSON object with the following fields:
    - "action_type": Choose one from ["click", "fill", "type", "press", "navigate", "scroll", "select_option", "warn_user", "clarify"].
    - "selector": (Required for most actions except navigate/global press/scroll/warn_user/clarify) A concise and robust CSS selector for the target element. If multiple good selectors exist, provide a comma-separated list, ordered by preference.
    - "value": (Required for "fill", "type", "select_option") The text to type/fill or the value of the option to select.
    - "key": (Required for "press") The key to press (e.g., "Enter", "ArrowDown", "Tab").
    - "url": (Required for "navigate") The URL to navigate to.
    - "scroll_direction": (Required for "scroll") One of ["down", "up", "bottom", "top", "into_view"]. If "into_view", "selector" is also required.
    - "message": (Required for "warn_user" or "clarify") A message to the user if the instruction is ambiguous, requires information not present, or is unsafe.
    - "reasoning": (Optional) A brief explanation of why you chose this action and selector.

    Prioritize actions that directly address the instruction. If a selector is not obvious, provide a few good alternatives.
    If the instruction is too vague (e.g., "do something"), or requires external knowledge not provided, use "clarify" and ask for more specific instructions.
    If the instruction seems potentially harmful or impossible (e.g., "delete system files via browser"), use "warn_user".
    
    Example Instruction: "Click the main login button."
    Page Context: "Title: Login Page. Buttons: ['Login', 'Forgot Password']. Inputs: 2."
    Example Response: {"action_type": "click", "selector": "button:has-text('Login'), input[type='submit'][value='Login']", "reasoning": "Identified 'Login' button as the most likely target."}

    Example Instruction: "Type 'myusername' in the user field."
    Page Context: "Title: Sign In. Inputs: ['Username', 'Password']."
    Example Response: {"action_type": "fill", "selector": "input[name*='user'], input[id*='user'], input[placeholder*='User']", "value": "myusername", "reasoning": "Identified input field likely related to username."}
    """

    class ActionExecutor:
        def __init__(self, llm_model: Optional[str] = None):
            self.api_key = os.getenv("OPENAI_API_KEY")
            self.llm_model = llm_model or os.getenv("BROWSER_LLM_MODEL", "gpt-4o-mini")
            if not self.api_key:
                raise ValueError("OpenAI API key required for ActionExecutor.")
            self.llm_client = OpenAI(api_key=self.api_key)
            logger.info(f"ActionExecutor: Initialized with OpenAI model '{self.llm_model}'.")

        async def _get_page_summary_for_llm(self, page: PWPage, max_elements: int = 10, max_len_per_element: int = 50) -> str:
            """Gets a brief summary of the current page for LLM context."""
            try:
                page_title = await page.title()
                page_url = page.url
                
                # Get some interactive elements (buttons, inputs, links)
                interactive_elements_summary = []
                
                # Buttons
                buttons = await page.locator("button, input[type='submit'], input[type='button'], [role='button']").all()
                for i, btn in enumerate(buttons[:max_elements]):
                    try:
                        text = (await btn.text_content(timeout=500) or await btn.get_attribute("value") or await btn.get_attribute("aria-label") or "Unnamed Button").strip()
                        if text: interactive_elements_summary.append(f"Button: '{text[:max_len_per_element]}'")
                    except PlaywrightTimeoutError: pass # Ignore if element disappears or text cannot be fetched quickly

                # Inputs
                inputs = await page.locator("input[type='text'], input[type='search'], input[type='email'], input[type='password'], input[type='number'], textarea, select").all()
                for i, inp in enumerate(inputs[:max_elements]):
                    try:
                        name = (await inp.get_attribute("name") or await inp.get_attribute("id") or await inp.get_attribute("placeholder") or "Unnamed Input").strip()
                        if name: interactive_elements_summary.append(f"Input: '{name[:max_len_per_element]}'")
                    except PlaywrightTimeoutError: pass
                
                # Links
                links = await page.locator("a[href]").all()
                for i, link in enumerate(links[:max_elements]):
                    try:
                        text = (await link.text_content(timeout=500) or await link.get_attribute("aria-label") or "Unnamed Link").strip()
                        if text: interactive_elements_summary.append(f"Link: '{text[:max_len_per_element]}'")
                    except PlaywrightTimeoutError: pass

                summary = f"Current URL: {page_url}\nPage Title: {page_title}\nVisible Interactive Elements:\n" + "\n".join(f"- {s}" for s in interactive_elements_summary)
                return summary
            except Exception as e:
                logger.warning(f"ActionExecutor: Error getting page summary for LLM: {e}")
                return f"Current URL: {page.url}\nPage Title: {await page.title()}\n(Could not retrieve detailed element summary)"


        async def _translate_instruction_to_action(self, page_context_summary: str, instruction: str) -> Optional[Dict[str, Any]]:
            prompt = f"""
            Current Page Context:
            ---
            {page_context_summary}
            ---
            User Instruction: "{instruction}"

            Based on the page context and user instruction, determine the single, most direct browser action to perform.
            Respond with a JSON object following the specified schema.
            """
            messages = [
                {"role": "system", "content": ACTION_TRANSLATION_SYSTEM_PROMPT},
                {"role": "user", "content": prompt}
            ]
            logger.debug(f"ActionExecutor LLM Prompt for action translation:\nSystem: {ACTION_TRANSLATION_SYSTEM_PROMPT}\nUser: {prompt}")

            try:
                response = await asyncio.to_thread(
                    self.llm_client.chat.completions.create,
                    model=self.llm_model, messages=messages,
                    response_format={"type": "json_object"}, temperature=0.1
                )
                action_json_str = response.choices[0].message.content
                action_dict = json.loads(action_json_str)
                logger.info(f"ActionExecutor LLM translation: '{instruction}' -> {action_dict}")
                return action_dict
            except json.JSONDecodeError as jde:
                logger.error(f"ActionExecutor: LLM returned invalid JSON for instruction '{instruction}': {action_json_str}. Error: {jde}")
            except BadRequestError as bre: # Often due to context length or bad input to OpenAI
                 logger.error(f"ActionExecutor: OpenAI BadRequestError: {bre}. Instruction: '{instruction}'")
            except APIError as apie:
                logger.error(f"ActionExecutor: OpenAI APIError for instruction '{instruction}': {apie}")
            except Exception as e:
                logger.error(f"ActionExecutor: Unexpected error calling LLM for instruction translation: {e}", exc_info=True)
            return None

        async def execute_ai_action(self, page: PWPage, instruction: str) -> Dict[str, Any]:
            logger.info(f"ActionExecutor: Attempting AI action on page {page.url}. Instruction: '{instruction}'")
            
            page_context_summary = await self._get_page_summary_for_llm(page)
            parsed_action = await self._translate_instruction_to_action(page_context_summary, instruction)

            if not parsed_action or not isinstance(parsed_action, dict):
                return {"status": "error", "message": "LLM could not parse instruction into a valid action.", "original_instruction": instruction}

            action_type = parsed_action.get("action_type")
            if not action_type:
                return {"status": "error", "message": "LLM response missing 'action_type'.", "parsed_response": parsed_action}

            if action_type == "warn_user" or action_type == "clarify":
                return {"status": "clarification_needed", "message": parsed_action.get("message", "The LLM planner requires clarification or warns about the instruction."), "details": parsed_action}

            selector_str = parsed_action.get("selector")
            value = parsed_action.get("value")
            key_to_press = parsed_action.get("key")
            url_to_navigate = parsed_action.get("url")
            scroll_direction = parsed_action.get("scroll_direction")
            option_value = parsed_action.get("option_value") # For select_option

            action_details_log = {"type": action_type, "selector_input": selector_str, "value": value, "key": key_to_press, "url": url_to_navigate}

            try:
                target_locator = None
                final_selector_used = None
                if selector_str and action_type not in ["navigate", "scroll"]: # Scroll might use selector for "into_view"
                    possible_selectors = [s.strip() for s in selector_str.split(',') if s.strip()]
                    if not possible_selectors and action_type != "press": # Press can be global
                         raise PlaywrightError(f"LLM provided an empty or invalid selector string: '{selector_str}'")

                    for sel_option in possible_selectors:
                        try:
                            locator = page.locator(sel_option)
                            # Check for visibility, and enabled for interactive elements. Timeout quickly.
                            await locator.wait_for(state="visible", timeout=1500)
                            if action_type in ["click", "fill", "type", "press", "select_option"]:
                                await locator.wait_for(state="enabled", timeout=1500)
                            target_locator = locator
                            final_selector_used = sel_option
                            logger.info(f"ActionExecutor: Using selector '{final_selector_used}' for action '{action_type}'.")
                            break
                        except PlaywrightTimeoutError:
                            logger.debug(f"ActionExecutor: Selector option '{sel_option}' not visible/enabled within timeout.")
                            continue
                        except PlaywrightError as e: # Invalid selector syntax
                            logger.warning(f"ActionExecutor: Invalid selector option '{sel_option}': {e}")
                            continue
                    
                    if not target_locator and action_type not in ["press"]: # Global press is allowed
                        raise PlaywrightError(f"None of the suggested selectors found or were ready: {possible_selectors}")
                
                action_taken_message = ""
                if action_type == "click":
                    if not target_locator: raise PlaywrightError("No element found for click.")
                    await target_locator.click(timeout=5000)
                    action_taken_message = f"Clicked element: {final_selector_used}"
                elif action_type == "fill":
                    if not target_locator: raise PlaywrightError("No element found for fill.")
                    await target_locator.fill(value or "", timeout=5000)
                    action_taken_message = f"Filled element '{final_selector_used}'."
                elif action_type == "type":
                    if not target_locator: raise PlaywrightError("No element found for type.")
                    await target_locator.type(value or "", delay=50, timeout=10000)
                    action_taken_message = f"Typed into element '{final_selector_used}'."
                elif action_type == "press":
                    if key_to_press is None: raise ValueError("'key' parameter is required for 'press' action.")
                    if target_locator:
                        await target_locator.press(key_to_press, timeout=5000)
                        action_taken_message = f"Pressed key '{key_to_press}' on element '{final_selector_used}'."
                    else: # Global key press
                        await page.keyboard.press(key_to_press)
                        action_taken_message = f"Pressed key '{key_to_press}' globally."
                elif action_type == "navigate":
                    if not url_to_navigate: raise ValueError("URL required for navigate action.")
                    await page.goto(url_to_navigate, timeout=60000, wait_until="domcontentloaded")
                    action_taken_message = f"Navigated to {url_to_navigate}."
                elif action_type == "scroll":
                    if scroll_direction == "into_view":
                        if not target_locator: raise PlaywrightError("Selector required for scroll 'into_view'.")
                        await target_locator.scroll_into_view_if_needed(timeout=5000)
                        action_taken_message = f"Scrolled element '{final_selector_used}' into view."
                    elif scroll_direction == "down": await page.mouse.wheel(0, 800) # Increased scroll amount
                    elif scroll_direction == "up": await page.mouse.wheel(0, -800)
                    elif scroll_direction == "bottom": await page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
                    elif scroll_direction == "top": await page.evaluate("window.scrollTo(0, 0)")
                    else: raise ValueError(f"Invalid scroll_direction: {scroll_direction}")
                    action_taken_message = f"Scrolled page {scroll_direction}."
                elif action_type == "select_option":
                    if not target_locator: raise PlaywrightError("No element found for select_option.")
                    if option_value is None: raise ValueError("'option_value' required for select_option.")
                    await target_locator.select_option(value=option_value) # Can also select by label or index
                    action_taken_message = f"Selected option '{option_value}' in '{final_selector_used}'."
                else: # Should have been caught by earlier check if action_type was invalid from LLM
                    return {"status": "error", "message": f"Unsupported action_type: {action_type}", "parsed_action": parsed_action}

                await asyncio.sleep(0.2) # Short pause for page to settle after action
                # await page.wait_for_load_state("networkidle", timeout=3000) # Or networkidle if more stability needed
                
                logger.info(f"ActionExecutor: Successfully executed: {action_taken_message}")
                return {"status": "success", "action_taken": action_taken_message, "target_url": page.url, "final_selector_used": final_selector_used}

            except PlaywrightTimeoutError as pte:
                error_msg = f"Playwright Timeout during '{action_type}' on '{final_selector_used or selector_str}': Target not ready or action took too long. {str(pte)}"
                logger.warning(error_msg)
                return {"status": "error", "message": error_msg, "details": action_details_log}
            except PlaywrightError as pe:
                error_msg = f"Playwright Error during '{action_type}' on '{final_selector_used or selector_str}': {str(pe)}"
                logger.warning(error_msg) # Log as warning as it might be due to bad selector from LLM
                return {"status": "error", "message": error_msg, "details": action_details_log}
            except Exception as e:
                error_msg = f"Unexpected error during '{action_type}': {str(e)}"
                logger.error(error_msg, exc_info=True)
                return {"status": "error", "message": error_msg, "details": action_details_log}

        # ... (extract_data method as in Task 23)
```

**Key changes in `ActionExecutor`:**
*   **Refined System Prompt:** `ACTION_TRANSLATION_SYSTEM_PROMPT` is made more specific, asking for a single action and providing "warn_user" / "clarify" as fallback action types. It also requests a `reasoning` field.
*   **`_get_page_summary_for_llm`:** A new helper to provide some context from the current page (title, some interactive elements) to the LLM to aid in selector generation. This is a very simplified version of what Stagehand might do.
*   **Error Handling in `_translate_instruction_to_action`:** Catches JSONDecodeError and other LLM call errors.
*   **Selector Handling in `execute_ai_action`:** If the LLM returns multiple comma-separated selectors, it tries them in order until one works.
*   **Action Execution:** Implements Playwright calls for `click`, `fill`, `type`, `press`, `navigate`, `scroll`, `select_option`. Includes basic timeouts.
*   **Status Reporting:** Returns a dictionary with `status` ("success", "error", "clarification_needed") and relevant messages/details.

3.  **Modify `python/tools/browser_agent_tool.py`:**
    *   The `_ai_act` method in `BrowserAgentTool` will receive the structured dictionary from `ActionExecutor.execute_ai_action`. It should interpret the status and potentially pass "clarification_needed" messages back to the agent/user.

    ```python
# python/tools/browser_agent_tool.py
    # ... (imports and __init__ as before)

    class BrowserAgentTool(Tool):
        # ... (other methods)

        async def _ai_act(self, page: PWPage, instructions: str, session_id: str, page_index: int) -> ToolResponse:
            action_name = "ai_act"
            await self._emit_browser_event(action_name, "processing", {"instructions": instructions, "session_id": session_id, "page_index": page_index})
            
            act_result = await self.action_executor.execute_ai_action(page, instructions) # This now returns a richer dict
            
            status = act_result.get("status", "error")
            message = act_result.get("message", "Action processing finished.")
            data_to_return = act_result # Return the full result dict as data

            if status == "success":
                await self._emit_browser_event(action_name, "completed", {"result": act_result, "session_id": session_id, "page_index": page_index})
                return ToolResponse(message=act_result.get("action_taken", message), data=data_to_return)
            elif status == "clarification_needed":
                await self._emit_browser_event(action_name, "clarification_needed", {"message": message, "details": act_result.get("details"), "session_id": session_id})
                # The agent loop will need to handle this type of response, perhaps by asking the user.
                return ToolResponse(message=f"Clarification needed: {message}", data=data_to_return, error=False, requires_clarification=True) # Added a new flag for agent
            else: # Error
                await self.agent._emit_stream_event(StreamEventType.ERROR_EVENT, {"source_tool": self.name, "action": action_name, "error": message, "details": act_result})
                return ToolResponse(message=message, error=True, data=data_to_return)
```
    **Note on `ToolResponse`:** We might need to extend `ToolResponse` or how the agent interprets it to handle a "clarification_needed" state differently from a hard error or success. For now, I've added a conceptual `requires_clarification=True` flag.

**Dependencies/Prerequisites:**
*   Task 12 (Playwright navigation), Task 22 (basic `act` structure).
*   `openai` library for LLM calls.
*   `PLAYWRIGHT_BROWSERS_PATH` and browser binaries installed.
*   `OPENAI_API_KEY` and a suitable `BROWSER_LLM_MODEL` (or `OPENAI_MODEL`) configured.

**Integration with Agent Zero:**
*   `ActionExecutor` uses an LLM to translate natural language into executable browser actions.
*   `BrowserAgentTool._ai_act` calls `ActionExecutor` and handles its structured response, including potential requests for clarification.
*   The main agent loop would need to be adapted to handle a `ToolResponse` that indicates `requires_clarification` (e.g., by pausing and asking the user for more details, similar to `HUMAN_INTERVENTION`).

**Chatterbox TTS Integration Requirements for this Task:**
*   None directly.

**Docker Compatibility:**
*   All dependencies (`playwright`, `openai`) must be in `requirements.txt`.
*   Environment variables for OpenAI API access are crucial.
*   Playwright browser dependencies within Docker.

**Summary of Task 41:**
This task significantly upgrades the `act` action of the `BrowserAgentTool`. It introduces LLM-based translation of natural language instructions into specific, simple browser operations (click, type, fill, etc.) with CSS selector identification. The `ActionExecutor` now attempts to execute these parsed actions using Playwright. This forms the basis for more intelligent and flexible browser automation, though it's still a step away from the full context-aware reasoning of advanced systems like Stagehand. The system can also now indicate when an instruction is unclear and requires clarification.

Please confirm to proceed.Okay, let's proceed with Task 41, which is the first step in fleshing out the `BrowserAgentTool` with real AI-driven logic.

## Task 41: `BrowserAgentTool` - Implement Real AI-driven `act` Logic (LLM-based Action Execution for Basic Actions)

**Focus:**
This task evolves the `BrowserAgentTool`'s `act` functionality by implementing the LLM call within `ActionExecutor` to translate natural language instructions into specific, simple Playwright actions. We will refine the interaction with the LLM and the execution of the parsed actions. The goal is to reliably perform basic actions like clicking identified elements and typing/filling input fields based on reasonably clear natural language.

**Assumptions:**
*   The LLM (e.g., "gpt-4o-mini") is capable of understanding the `ACTION_TRANSLATION_SYSTEM_PROMPT` and returning a JSON object with `action_type`, `selector`, and `value`/`key` as defined in Task 22.
*   Playwright is set up and `BrowserManager` can provide a valid `Page` object.

**File Paths and Code Changes:**

1.  **Refine `python/agents/browser_agent/actions.py` (`ActionExecutor`):**
    *   Enhance `_translate_instruction_to_action` for more robust LLM interaction and error handling.
    *   Enhance `execute_ai_action` to more reliably execute the LLM's suggested actions using Playwright, including handling cases where a selector might not be immediately found or is ambiguous. This version will still focus on direct execution of the LLM's *single* suggested action rather than a Stagehand-like multi-step reasoning over the page.

    ```python
    # python/agents/browser_agent/actions.py
    import asyncio
    from typing import Dict, Any, Optional, List
    from playwright.async_api import Page as PWPage, PlaywrightError, TimeoutError as PlaywrightTimeoutError
    import json
    import os
    import re # For simple text cleaning
    from openai import OpenAI, APIError, RateLimitError, BadRequestError
    from dotenv import load_dotenv
    from pathlib import Path
    import logging

    logger = logging.getLogger(__name__)

    project_root = Path(__file__).resolve().parents[2] # Adjust if structure changes
    dotenv_path = project_root / '.env'
    load_dotenv(dotenv_path, override=True)

    ACTION_TRANSLATION_SYSTEM_PROMPT = """
    You are an expert at translating natural language browser interaction commands into specific Playwright actions and CSS selectors.
    Given current page context (like title and interactive elements) and a user instruction, identify the single, most direct browser action to perform.
    Respond with a JSON object with the following fields:
    - "action_type": Choose one from ["click", "fill", "type", "press", "navigate", "scroll", "select_option", "warn_user", "clarify"].
    - "selector": (Required for most actions except navigate/global press/scroll/warn_user/clarify) A concise and robust CSS selector for the target element. If multiple good selectors exist, provide a comma-separated list, ordered by preference.
    - "value": (Required for "fill", "type", "select_option") The text to type/fill or the value of the option to select.
    - "key": (Required for "press") The key to press (e.g., "Enter", "ArrowDown", "Tab").
    - "url": (Required for "navigate") The URL to navigate to.
    - "scroll_direction": (Required for "scroll") One of ["down", "up", "bottom", "top", "into_view"]. If "into_view", "selector" is also required.
    - "message": (Required for "warn_user" or "clarify") A message to the user if the instruction is ambiguous, requires information not present, or is unsafe.
    - "reasoning": (Optional) A brief explanation of why you chose this action and selector.

    Prioritize actions that directly address the instruction. If a selector is not obvious, provide a few good alternatives.
    If the instruction is too vague (e.g., "do something"), or requires external knowledge not provided, use "clarify" and ask for more specific instructions.
    If the instruction seems potentially harmful or impossible (e.g., "delete system files via browser"), use "warn_user".
    
    Example Instruction: "Click the main login button."
    Page Context: "Title: Login Page. Buttons: ['Login', 'Forgot Password']. Inputs: 2."
    Example Response: {"action_type": "click", "selector": "button:has-text('Login'), input[type='submit'][value='Login']", "reasoning": "Identified 'Login' button as the most likely target."}

    Example Instruction: "Type 'myusername' in the user field."
    Page Context: "Title: Sign In. Inputs: ['Username', 'Password']."
    Example Response: {"action_type": "fill", "selector": "input[name*='user'], input[id*='user'], input[placeholder*='User']", "value": "myusername", "reasoning": "Identified input field likely related to username."}
    """

    class ActionExecutor:
        def __init__(self, llm_model: Optional[str] = None):
            self.api_key = os.getenv("OPENAI_API_KEY")
            self.llm_model = llm_model or os.getenv("BROWSER_LLM_MODEL", "gpt-4o-mini")
            if not self.api_key:
                raise ValueError("OpenAI API key required for ActionExecutor.")
            self.llm_client = OpenAI(api_key=self.api_key)
            logger.info(f"ActionExecutor: Initialized with OpenAI model '{self.llm_model}'.")

        async def _get_page_summary_for_llm(self, page: PWPage, max_elements: int = 10, max_len_per_element: int = 50) -> str:
            """Gets a brief summary of the current page for LLM context."""
            try:
                page_title = await page.title()
                page_url = page.url
                
                # Get some interactive elements (buttons, inputs, links)
                interactive_elements_summary = []
                
                # Buttons
                buttons = await page.locator("button, input[type='submit'], input[type='button'], [role='button']").all()
                for i, btn in enumerate(buttons[:max_elements]):
                    try:
                        text = (await btn.text_content(timeout=500) or await btn.get_attribute("value") or await btn.get_attribute("aria-label") or "Unnamed Button").strip()
                        if text: interactive_elements_summary.append(f"Button: '{text[:max_len_per_element]}'")
                    except PlaywrightTimeoutError: pass # Ignore if element disappears or text cannot be fetched quickly

                # Inputs
                inputs = await page.locator("input[type='text'], input[type='search'], input[type='email'], input[type='password'], input[type='number'], textarea, select").all()
                for i, inp in enumerate(inputs[:max_elements]):
                    try:
                        name = (await inp.get_attribute("name") or await inp.get_attribute("id") or await inp.get_attribute("placeholder") or "Unnamed Input").strip()
                        if name: interactive_elements_summary.append(f"Input: '{name[:max_len_per_element]}'")
                    except PlaywrightTimeoutError: pass
                
                # Links
                links = await page.locator("a[href]").all()
                for i, link in enumerate(links[:max_elements]):
                    try:
                        text = (await link.text_content(timeout=500) or await link.get_attribute("aria-label") or "Unnamed Link").strip()
                        if text: interactive_elements_summary.append(f"Link: '{text[:max_len_per_element]}'")
                    except PlaywrightTimeoutError: pass

                summary = f"Current URL: {page_url}\nPage Title: {page_title}\nVisible Interactive Elements:\n" + "\n".join(f"- {s}" for s in interactive_elements_summary)
                return summary
            except Exception as e:
                logger.warning(f"ActionExecutor: Error getting page summary for LLM: {e}")
                return f"Current URL: {page.url}\nPage Title: {await page.title()}\n(Could not retrieve detailed element summary)"


        async def _translate_instruction_to_action(self, page_context_summary: str, instruction: str) -> Optional[Dict[str, Any]]:
            prompt = f"""
            Current Page Context:
            ---
            {page_context_summary}
            ---
            User Instruction: "{instruction}"

            Based on the page context and user instruction, determine the single, most direct browser action to perform.
            Respond with a JSON object following the specified schema.
            """
            messages = [
                {"role": "system", "content": ACTION_TRANSLATION_SYSTEM_PROMPT},
                {"role": "user", "content": prompt}
            ]
            logger.debug(f"ActionExecutor LLM Prompt for action translation:\nSystem: {ACTION_TRANSLATION_SYSTEM_PROMPT}\nUser: {prompt}")

            try:
                response = await asyncio.to_thread(
                    self.llm_client.chat.completions.create,
                    model=self.llm_model, messages=messages,
                    response_format={"type": "json_object"}, temperature=0.1
                )
                action_json_str = response.choices[0].message.content
                action_dict = json.loads(action_json_str)
                logger.info(f"ActionExecutor LLM translation: '{instruction}' -> {action_dict}")
                return action_dict
            except json.JSONDecodeError as jde:
                logger.error(f"ActionExecutor: LLM returned invalid JSON for instruction '{instruction}': {action_json_str}. Error: {jde}")
            except BadRequestError as bre: # Often due to context length or bad input to OpenAI
                 logger.error(f"ActionExecutor: OpenAI BadRequestError: {bre}. Instruction: '{instruction}'")
            except APIError as apie:
                logger.error(f"ActionExecutor: OpenAI APIError for instruction '{instruction}': {apie}")
            except Exception as e:
                logger.error(f"ActionExecutor: Unexpected error calling LLM for instruction translation: {e}", exc_info=True)
            return None

        async def execute_ai_action(self, page: PWPage, instruction: str) -> Dict[str, Any]:
            logger.info(f"ActionExecutor: Attempting AI action on page {page.url}. Instruction: '{instruction}'")
            
            page_context_summary = await self._get_page_summary_for_llm(page)
            parsed_action = await self._translate_instruction_to_action(page_context_summary, instruction)

            if not parsed_action or not isinstance(parsed_action, dict):
                return {"status": "error", "message": "LLM could not parse instruction into a valid action.", "original_instruction": instruction}

            action_type = parsed_action.get("action_type")
            if not action_type:
                return {"status": "error", "message": "LLM response missing 'action_type'.", "parsed_response": parsed_action}

            if action_type == "warn_user" or action_type == "clarify":
                return {"status": "clarification_needed", "message": parsed_action.get("message", "The LLM planner requires clarification or warns about the instruction."), "details": parsed_action}

            selector_str = parsed_action.get("selector")
            value = parsed_action.get("value")
            key_to_press = parsed_action.get("key")
            url_to_navigate = parsed_action.get("url")
            scroll_direction = parsed_action.get("scroll_direction")
            option_value = parsed_action.get("option_value") # For select_option

            action_details_log = {"type": action_type, "selector_input": selector_str, "value": value, "key": key_to_press, "url": url_to_navigate}

            try:
                target_locator = None
                final_selector_used = None
                if selector_str and action_type not in ["navigate", "scroll"]: # Scroll might use selector for "into_view"
                    possible_selectors = [s.strip() for s in selector_str.split(',') if s.strip()]
                    if not possible_selectors and action_type != "press": # Press can be global
                         raise PlaywrightError(f"LLM provided an empty or invalid selector string: '{selector_str}'")

                    for sel_option in possible_selectors:
                        try:
                            locator = page.locator(sel_option)
                            # Check for visibility, and enabled for interactive elements. Timeout quickly.
                            await locator.wait_for(state="visible", timeout=1500)
                            if action_type in ["click", "fill", "type", "press", "select_option"]:
                                await locator.wait_for(state="enabled", timeout=1500)
                            target_locator = locator
                            final_selector_used = sel_option
                            logger.info(f"ActionExecutor: Using selector '{final_selector_used}' for action '{action_type}'.")
                            break
                        except PlaywrightTimeoutError:
                            logger.debug(f"ActionExecutor: Selector option '{sel_option}' not visible/enabled within timeout.")
                            continue
                        except PlaywrightError as e: # Invalid selector syntax
                            logger.warning(f"ActionExecutor: Invalid selector option '{sel_option}': {e}")
                            continue
                    
                    if not target_locator and action_type not in ["press"]: # Global press is allowed
                        raise PlaywrightError(f"None of the suggested selectors found or were ready: {possible_selectors}")
                
                action_taken_message = ""
                if action_type == "click":
                    if not target_locator: raise PlaywrightError("No element found for click.")
                    await target_locator.click(timeout=5000)
                    action_taken_message = f"Clicked element: {final_selector_used}"
                elif action_type == "fill":
                    if not target_locator: raise PlaywrightError("No element found for fill.")
                    await target_locator.fill(value or "", timeout=5000)
                    action_taken_message = f"Filled element '{final_selector_used}'."
                elif action_type == "type":
                    if not target_locator: raise PlaywrightError("No element found for type.")
                    await target_locator.type(value or "", delay=50, timeout=10000)
                    action_taken_message = f"Typed into element '{final_selector_used}'."
                elif action_type == "press":
                    if key_to_press is None: raise ValueError("'key' parameter is required for 'press' action.")
                    if target_locator:
                        await target_locator.press(key_to_press, timeout=5000)
                        action_taken_message = f"Pressed key '{key_to_press}' on element '{final_selector_used}'."
                    else: # Global key press
                        await page.keyboard.press(key_to_press)
                        action_taken_message = f"Pressed key '{key_to_press}' globally."
                elif action_type == "navigate":
                    if not url_to_navigate: raise ValueError("URL required for navigate action.")
                    await page.goto(url_to_navigate, timeout=60000, wait_until="domcontentloaded")
                    action_taken_message = f"Navigated to {url_to_navigate}."
                elif action_type == "scroll":
                    if scroll_direction == "into_view":
                        if not target_locator: raise PlaywrightError("Selector required for scroll 'into_view'.")
                        await target_locator.scroll_into_view_if_needed(timeout=5000)
                        action_taken_message = f"Scrolled element '{final_selector_used}' into view."
                    elif scroll_direction == "down": await page.mouse.wheel(0, 800) # Increased scroll amount
                    elif scroll_direction == "up": await page.mouse.wheel(0, -800)
                    elif scroll_direction == "bottom": await page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
                    elif scroll_direction == "top": await page.evaluate("window.scrollTo(0, 0)")
                    else: raise ValueError(f"Invalid scroll_direction: {scroll_direction}")
                    action_taken_message = f"Scrolled page {scroll_direction}."
                elif action_type == "select_option":
                    if not target_locator: raise PlaywrightError("No element found for select_option.")
                    if option_value is None: raise ValueError("'option_value' required for select_option.")
                    await target_locator.select_option(value=option_value) # Can also select by label or index
                    action_taken_message = f"Selected option '{option_value}' in '{final_selector_used}'."
                else: # Should have been caught by earlier check if action_type was invalid from LLM
                    return {"status": "error", "message": f"Unsupported action_type: {action_type}", "parsed_action": parsed_action}

                await asyncio.sleep(0.2) # Short pause for page to settle after action
                # await page.wait_for_load_state("networkidle", timeout=3000) # Or networkidle if more stability needed
                
                logger.info(f"ActionExecutor: Successfully executed: {action_taken_message}")
                return {"status": "success", "action_taken": action_taken_message, "target_url": page.url, "final_selector_used": final_selector_used}

            except PlaywrightTimeoutError as pte:
                error_msg = f"Playwright Timeout during '{action_type}' on '{final_selector_used or selector_str}': Target not ready or action took too long. {str(pte)}"
                logger.warning(error_msg)
                return {"status": "error", "message": error_msg, "details": action_details_log}
            except PlaywrightError as pe:
                error_msg = f"Playwright Error during '{action_type}' on '{final_selector_used or selector_str}': {str(pe)}"
                logger.warning(error_msg) # Log as warning as it might be due to bad selector from LLM
                return {"status": "error", "message": error_msg, "details": action_details_log}
            except Exception as e:
                error_msg = f"Unexpected error during '{action_type}': {str(e)}"
                logger.error(error_msg, exc_info=True)
                return {"status": "error", "message": error_msg, "details": action_details_log}

        # ... (extract_data method as in Task 23)
    ```

**Key changes in `ActionExecutor`:**
*   **Refined System Prompt:** `ACTION_TRANSLATION_SYSTEM_PROMPT` is made more specific, asking for a single action and providing "warn_user" / "clarify" as fallback action types. It also requests a `reasoning` field.
*   **`_get_page_summary_for_llm`:** A new helper to provide some context from the current page (title, some interactive elements) to the LLM to aid in selector generation. This is a very simplified version of what Stagehand might do.
*   **Error Handling in `_translate_instruction_to_action`:** Catches JSONDecodeError and other LLM call errors.
*   **Selector Handling in `execute_ai_action`:** If the LLM returns multiple comma-separated selectors, it tries them in order until one works.
*   **Action Execution:** Implements Playwright calls for `click`, `fill`, `type`, `press`, `navigate`, `scroll`, `select_option`. Includes basic timeouts.
*   **Status Reporting:** Returns a dictionary with `status` ("success", "error", "clarification_needed") and relevant messages/details.

3.  **Modify `python/tools/browser_agent_tool.py`:**
    *   The `_ai_act` method in `BrowserAgentTool` will receive the structured dictionary from `ActionExecutor.execute_ai_action`. It should interpret the status and potentially pass "clarification_needed" messages back to the agent/user.

    ```python
    # python/tools/browser_agent_tool.py
    # ... (imports and __init__ as before)

    class BrowserAgentTool(Tool):
        # ... (other methods)

        async def _ai_act(self, page: PWPage, instructions: str, session_id: str, page_index: int) -> ToolResponse:
            action_name = "ai_act"
            await self._emit_browser_event(action_name, "processing", {"instructions": instructions, "session_id": session_id, "page_index": page_index})
            
            act_result = await self.action_executor.execute_ai_action(page, instructions) # This now returns a richer dict
            
            status = act_result.get("status", "error")
            message = act_result.get("message", "Action processing finished.")
            data_to_return = act_result # Return the full result dict as data

            if status == "success":
                await self._emit_browser_event(action_name, "completed", {"result": act_result, "session_id": session_id, "page_index": page_index})
                return ToolResponse(message=act_result.get("action_taken", message), data=data_to_return)
            elif status == "clarification_needed":
                await self._emit_browser_event(action_name, "clarification_needed", {"message": message, "details": act_result.get("details"), "session_id": session_id})
                # The agent loop will need to handle this type of response, perhaps by asking the user.
                return ToolResponse(message=f"Clarification needed: {message}", data=data_to_return, error=False, requires_clarification=True) # Added a new flag for agent
            else: # Error
                await self.agent._emit_stream_event(StreamEventType.ERROR_EVENT, {"source_tool": self.name, "action": action_name, "error": message, "details": act_result})
                return ToolResponse(message=message, error=True, data=data_to_return)
    ```
    **Note on `ToolResponse`:** We might need to extend `ToolResponse` or how the agent interprets it to handle a "clarification_needed" state differently from a hard error or success. For now, I've added a conceptual `requires_clarification=True` flag.

**Dependencies/Prerequisites:**
*   Task 12 (Playwright navigation), Task 22 (basic `act` structure).
*   `openai` library for LLM calls.
*   `PLAYWRIGHT_BROWSERS_PATH` and browser binaries installed.
*   `OPENAI_API_KEY` and a suitable `BROWSER_LLM_MODEL` (or `OPENAI_MODEL`) configured.

**Integration with Agent Zero:**
*   `ActionExecutor` uses an LLM to translate natural language into executable browser actions.
*   `BrowserAgentTool._ai_act` calls `ActionExecutor` and handles its structured response, including potential requests for clarification.
*   The main agent loop would need to be adapted to handle a `ToolResponse` that indicates `requires_clarification` (e.g., by pausing and asking the user for more details, similar to `HUMAN_INTERVENTION`).

**Chatterbox TTS Integration Requirements for this Task:**
*   None directly.

**Docker Compatibility:**
*   All dependencies (`playwright`, `openai`) must be in `requirements.txt`.
*   Environment variables for OpenAI API access are crucial.
*   Playwright browser dependencies within Docker.

**Summary of Task 41:**
This task significantly upgrades the `act` action of the `BrowserAgentTool`. It introduces LLM-based translation of natural language instructions into specific, simple browser operations (click, type, fill, etc.) with CSS selector identification. The `ActionExecutor` now attempts to execute these parsed actions using Playwright. This forms the basis for more intelligent and flexible browser automation, though it's still a step away from the full context-aware reasoning of advanced systems like Stagehand. The system can also now indicate when an instruction is unclear and requires clarification.

Please confirm to proceed.